<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>JS Reference VS Copy</title>
  </head>
  <body>
    <p><em>Psst: have a look at the JavaScript Console</em> ğŸ’</p>
    <script>
      // start with strings, numbers and booleans
      // å¾å­—ä¸²ã€æ•¸å­—å’Œå¸ƒæ—å€¼é–‹å§‹

      let age = 100;
      let age2 = age;
      console.log('age:' + age, 'age2:' + age2); // 100, 100
      age = 200;
      console.log('age:' + age, 'age2:' + age2); // 200, 100

      /*
          1. å…ˆåœ¨é›»è…¦è¨˜æ†¶é«”å‰µé€ æ•¸å€¼ 100
          2. å‰µé€ ä¸€å€‹è®Šæ•¸ age ä¸¦è¨­å®šåˆ°é›»è…¦è¨˜æ†¶é«”
          3. å°‡è®Šæ•¸ age æŒ‡å‘é›»è…¦è¨˜æ†¶é«”å…§çš„ 100
          4. é›»è…¦æ‹·è² age çš„å€¼ï¼Œåœ¨é›»è…¦è¨˜æ†¶é«”ä¸­è¨­å®šå¦ä¸€å€‹ 100
          5. å°‡è®Šæ•¸ age2 æŒ‡å‘é›»è…¦è¨˜æ†¶é«”å…§å¦ä¸€å€‹ 100 =>ï¼ˆage2 = 100ï¼‰
          6. åœ¨é›»è…¦è¨˜æ†¶é«”å‰µé€ æ•¸å€¼ 200
          7. å°‡è®Šæ•¸ age æŒ‡å‘é›»è…¦è¨˜æ†¶é«”å…§çš„ 200 =>ï¼ˆage = 200ï¼‰
      */

      let numA = 100;
      let numB = 100;
      let numC = 100;
      numB = 200;
      numC = 300;
      numA += numB; // numA = numA + numB
      numA += numC; // numA = numA + numC

      console.log('numA:' + numA, 'numB:' + numB, 'numC:' + numC); // 600, 300, 200

      // Let's say we have an array
      // å‡è¨­æˆ‘å€‘æœ‰ä¸€å€‹é™£åˆ—
      const players = ['Wes', 'Sarah', 'Ryan', 'Poppy'];

      // and we want to make a copy of it.
      // æˆ‘å€‘æƒ³è¦è¤‡è£½å®ƒ
      const team = players;
      console.log('players:' + players, 'team:' + team);

      // You might think we can just do something like this:
      // ä½ å¯èƒ½èªç‚ºæˆ‘å€‘å¯ä»¥åšé€™æ¨£çš„äº‹æƒ…
      team[3] = 'Max';

      // however what happens when we update that array?
      // ä½†æ˜¯ç•¶æˆ‘å€‘æ›´æ–°é‚£å€‹é™£åˆ—æ™‚æœƒç™¼ç”Ÿä»€éº¼äº‹?

      // now here is the problem!
      // ç¾åœ¨é€™æ˜¯å•é¡Œæ‰€åœ¨

      console.log('players:' + players, 'team:' + team);
      // players: 'Wes', 'Sarah', 'Ryan', 'Max'
      // team: 'Wes', 'Sarah', 'Ryan', 'Max'

      // oh no - we have edited the original array too!
      // å–”ä¸ æˆ‘å€‘ä¹Ÿç·¨è¼¯äº†åŸå§‹é™£åˆ—!

      // Why? It's because that is an array reference, not an array copy. They both point to the same array!
      // ç‚ºä»€éº¼ï¼Ÿ é€™æ˜¯å› ç‚ºé€™æ˜¯ä¸€å€‹é™£åˆ—(reference)ï¼Œè€Œä¸æ˜¯é™£åˆ—è¤‡è£½ã€‚å®ƒå€‘éƒ½æŒ‡å‘åŒä¸€å€‹é™£åˆ—ï¼

      // So, how do we fix this? We take a copy instead!
      // é‚£éº¼ï¼Œæˆ‘å€‘è©²å¦‚ä½•è§£æ±ºé€™å€‹å•é¡Œå‘¢ï¼Ÿ æˆ‘å€‘æ‹¿ä¸€ä»½å‰¯æœ¬ï¼

      // one way
      // æ–¹æ³•ä¸€ï¼šä½¿ç”¨ slice()ï¼Œä¾†ç”¢ç”Ÿä¸€å€‹æ–°é™£åˆ—ä¾†ä½œè¤‡è£½
      const players2 = ['Wes', 'Sarah', 'Ryan', 'Poppy'];
      const team2 = players2.slice();
      team2[3] = 'Max';

      console.log('players2:' + players2, 'team2:' + team2);
      // players2: 'Wes', 'Sarah', 'Ryan', 'Poppy'
      // team2: 'Wes', 'Sarah', 'Ryan', 'Max'

      // or create a new array and concat the old one in
      // æ–¹æ³•äºŒï¼šä½¿ç”¨ concat()ï¼Œå‰µå»ºä¸€å€‹æ–°é™£åˆ—ä¸¦å°‡èˆŠé™£åˆ—é€£æ¥èµ·ä¾†
      const players3 = ['Wes', 'Sarah', 'Ryan', 'Poppy'];
      const team3 = [].concat(players3);
      team3[3] = 'Max';

      console.log('players3:' + players3, 'team3:' + team3);
      // players3: 'Wes', 'Sarah', 'Ryan', 'Poppy'
      // team3: 'Wes', 'Sarah', 'Ryan', 'Max'

      // or use the new ES6 Spread
      // æ–¹æ³•ä¸‰ï¼šä½¿ç”¨ ES6 å±•é–‹é‹ç®—å­
      const players4 = ['Wes', 'Sarah', 'Ryan', 'Poppy'];
      const team4 = [...players4];
      team4[3] = 'Max';

      console.log('players4:' + players4, 'team4:' + team4);
      // players4: 'Wes', 'Sarah', 'Ryan', 'Poppy'
      // team4: 'Wes', 'Sarah', 'Ryan', 'Max'

      // è£œå…… æ–¹æ³•å››ï¼šä½¿ç”¨ ES6 Array.from() ä¹Ÿå¯ä»¥é”åˆ°è¤‡è£½æ•ˆæœ
      const players5 = ['Wes', 'Sarah', 'Ryan', 'Poppy'];
      const team5 = Array.from(players5);
      team5[3] = 'Max';

      console.log('players5:' + players5, 'team5:' + team5);
      // players5: 'Wes', 'Sarah', 'Ryan', 'Poppy'
      // team5: 'Wes', 'Sarah', 'Ryan', 'Max'

      // now when we update it, the original one isn't changed
      // ç¾åœ¨ç•¶æˆ‘å€‘æ›´æ–°å®ƒæ™‚ï¼ŒåŸä¾†çš„ä¸æœƒæ”¹è®Š

      // The same thing goes for objects, let's say we have a person object
      // ç‰©ä»¶ä¹Ÿæ˜¯å¦‚æ­¤ï¼Œå‡è¨­æˆ‘å€‘æœ‰ä¸€å€‹ person ç‰©ä»¶

      // with Objects
      // ç‰©ä»¶
      const person = {
        name: 'Wes Bos',
        age: 80
      };

      // and think we make a copy:
      // ä¸¦èªç‚ºæˆ‘å€‘è£½ä½œå‰¯æœ¬ï¼š
      const captain = person;
      captain.number = 99;

      // how do we take a copy instead?
      // æˆ‘å€‘å¦‚ä½•å–ä»£å‰¯æœ¬
      const person2 = {
        name: 'Wes Bos',
        age: 80
      };

      const captain2 = Object.assign({}, person, {
        name: 'Max',
        number: 100,
        age: 100
      });
      console.log(person2, captain2);
      // person: {name: "Wes Bos", age: 80, number: 99}
      // captain2: {name: "Max", age: 100, number: 100}

      // We will hopefully soon see the object ...spread
      // æˆ‘å€‘å¾ˆå¿«å°±æœƒçœ‹åˆ°é€™å€‹ç‰©ä»¶ ï¼ˆ...å±•é–‹é‹ç®—å­ï¼‰
      const person3 = {
        name: 'Wes Bos',
        age: 80
      };
      const captain3 = { ...person3 };
      captain3.name = 'Max';
      captain3.age = '10';

      console.log(person3, captain3);
      // person3: {name: "Wes Bos", age: 80, number: 99}
      // captain3: {name: "Max", age: 10, number: 100}

      // Things to note - this is only 1 level deep - both for Arrays and Objects. lodash has a cloneDeep method, but you should think twice before using it.
      // æ³¨æ„äº‹é … - é€™åªæœ‰ 1 ç´šæ·±åº¦ - å°æ–¼é™£åˆ—å’Œç‰©ä»¶ã€‚ lodash æœ‰ä¸€å€‹ cloneDeep æ–¹æ³•ï¼Œä½†åœ¨ä½¿ç”¨ä¹‹å‰ä½ æ‡‰è©²ä¸‰æ€è€Œå¾Œè¡Œã€‚

      const wes = {
        name: 'Wes',
        age: 100,
        social: {
          twitter: '@wesbos',
          facebook: 'wesbos.developer'
        }
      };

      // Object.assign() å±¬æ–¼æ·ºæ‹·è²ï¼ˆShallow Copyï¼‰
      // åœ¨å¤šéšå±¤çš„ object æ™‚æœƒç™¼ç¾åªæœ‰ç¬¬ä¸€å±¤ä¿®æ”¹æ™‚ï¼Œä¸æœƒç›¸äº’å½±éŸ¿åˆ°ï¼Œä½†åœ¨ç¬¬äºŒå±¤ç™¼ç¾æœƒç›¸äº’å½±éŸ¿ã€‚
      // æ‰€ä»¥ Object.assign åªèƒ½æ·ºè¤‡è£½ä¸€å±¤ï¼Œè‹¥ç¬¬äºŒå±¤ä»¥ä¸Šä¾èˆŠæ˜¯ å‚³å€(reference)
      const dev = Object.assign({}, wes);
      dev.name = 'Dev';
      dev.social.twitter = '@dev';

      // å› æ­¤ä½¿ç”¨ JSON.stringify() çš„æ–¹å¼å…ˆå°‡å…¶è½‰æ›ç‚ºå­—ä¸²ï¼Œåœ¨ä½¿ç”¨ JSON.parse() çš„æ–¹å¼å°‡å…¶è½‰å›ç‰©ä»¶ã€‚é€™æ¨£å°±å±¬æ–¼ä¸€å€‹æ–°çš„ç‰©ä»¶ã€‚é”åˆ°å¯è¤‡è£½äºŒå±¤ä»¥ä¸Šçš„ç‰©ä»¶ã€‚
      const dev2 = JSON.parse(JSON.stringify(wes));
      dev2.name = 'Dev2';
      dev2.social.twitter = '@dev2';

      console.log(wes, dev, dev2);
      // wes:
      // name: 'Wes',
      // age: 100,
      // social: {
      //   twitter: '@dev',
      //   facebook: 'wesbos.developer'
      // }

      // dev:
      // name: 'Dev',
      // age: 100,
      // social: {
      //   twitter: '@dev',
      //   facebook: 'wesbos.developer'
      // }

      // dev2:
      // name: 'Dev2',
      // age: 100,
      // social: {
      //   twitter: '@dev2',
      //   facebook: 'wesbos.developer'
      // }
    </script>
  </body>
</html>
