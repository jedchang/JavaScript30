<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Type Ahead 👀</title>
  </head>
  <body>
    <style>
      html {
        box-sizing: border-box;
        background: #ffc600;
        font-family: 'helvetica neue';
        font-size: 20px;
        font-weight: 200;
      }

      *,
      *:before,
      *:after {
        box-sizing: inherit;
      }

      input {
        width: 100%;
        padding: 20px;
      }

      .search-form {
        max-width: 400px;
        margin: 50px auto;
      }

      input.search {
        margin: 0;
        text-align: center;
        outline: 0;
        border: 10px solid #f7f7f7;
        width: 120%;
        left: -10%;
        position: relative;
        top: 10px;
        z-index: 2;
        border-radius: 5px;
        font-size: 40px;
        box-shadow: 0 0 5px rgba(0, 0, 0, 0.12), inset 0 0 2px rgba(0, 0, 0, 0.19);
      }

      .suggestions {
        margin: 0;
        padding: 0;
        position: relative;
        /*perspective: 20px;*/
      }

      .suggestions li {
        background: white;
        list-style: none;
        border-bottom: 1px solid #d8d8d8;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.14);
        margin: 0;
        padding: 20px;
        transition: background 0.2s;
        display: flex;
        justify-content: space-between;
        text-transform: capitalize;
      }

      .suggestions li:nth-child(even) {
        transform: perspective(100px) rotateX(3deg) translateY(2px) scale(1.001);
        background: linear-gradient(to bottom, #ffffff 0%, #efefef 100%);
      }

      .suggestions li:nth-child(odd) {
        transform: perspective(100px) rotateX(-3deg) translateY(3px);
        background: linear-gradient(to top, #ffffff 0%, #efefef 100%);
      }

      span.population {
        font-size: 15px;
      }

      .hl {
        background: #ffc600;
      }

      span.h1 {
        background: #ffc600;
      }
    </style>
    <form class="search-form">
      <input type="text" class="search" placeholder="City or State" />
      <ul class="suggestions">
        <li>Filter for a city</li>
        <li>or a state</li>
      </ul>
    </form>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.js"></script>
    <script>
      const endpoint =
        'https://gist.githubusercontent.com/Miserlou/c5cd8364bf9b2420bb29/raw/2bf258763cdddd704f8ffd3ea9a3e81d25e2c6f6/cities.json';

      // fetch() 是使用 Promise 資料接收後才會跑 then() 內容 而 fetch() 是已經包裝好的 Promise

      // fetch(endpoint).then(function(res) {
      //   res.json().then(function(obj) {
      //     console.log(obj);
      //   });
      // });

      /**
       *
       * jQ 獲取 ajax
       *
       */

      // 定義一個空陣列來接收 API
      // var cities = [];

      // $.ajax({
      //   url: endpoint,
      //   type: 'GET',
      //   dataType: 'text',
      //   success: function(res) {
      //     console.log('成功');
      //     cities = JSON.parse(res);
      //   },
      //   error: function() {
      //     console.log('接收失敗!');
      //   }
      // });

      /**
       *
       * Fetch API
       *
       */

      // 注意是用 const 常數，不能變更
      const cities = [];

      fetch(endpoint)
        // 第一個 then 使用 response.json() 來將資料轉成 json 格式
        .then(function(response) {
          return response.json();
        })
        // 第二個 then 裡面的 data 才是真正的 json 物件，如果沒透過 then 基本上也只是個 Promise 物件而已
        // 可以透過 blob()、json()、text() 轉成可用的資訊
        .then(function(data) {
          // console.log(data);
          // ES6 解構賦值，因為上面宣告陣列為常數(不能改變)，所以要將取得值在推回去原陣列
          cities.push(...data);
        });

      function displayMatches() {
        // 宣告要輸入過濾文字的值 去頭尾空白
        let filterTxt = this.value.trim();

        // 正規表達式 篩選過濾g(代表全部) i(代表不分大小寫)
        let regexp = new RegExp(filterTxt, 'gi');

        // filter() 過濾陣列，place 自定義名稱
        let filterArray = cities.filter(function(place) {
          // 回傳 match 符合搜索 city 的內容 或者 符合搜索 state 的內容
          return place.city.match(regexp) || place.state.match(regexp);
        });
        // console.log(filterArray); // 搜尋內容逐步減少

        // 針對每個陣列去產生 html 故使用map()
        // map 會回傳 return 的值 功用上用來處理陣列回傳新值產生新陣列 留空的 return 會產生 undefined
        let html = filterArray
          .map(function(place) {
            // 做出文字輸入時被 highlight 有底色效果 且用 replace() 來替換 regexp 內容
            let cityName = place.city.replace(regexp, `<span class="h1">${filterTxt}</span>`);
            let stateName = place.state.replace(regexp, `<span class="h1">${filterTxt}</span>`);

            // 獲取的 place.population 為字串，要變成數字才能作千分位
            // js 弱型別 (字串 * 1 = 會轉為數字)
            let populationNum = place.population * 1;
            console.log(typeof populationNum);

            // 一定要 return 來組 html
            // 後面數字也要新增千分位 可用 toLocaleString()
            return `
            <li>
              <span class="name">${cityName}, ${stateName}</span>
              <span class="population">${populationNum.toLocaleString()}</span>
            </li>
          `;
          })
          .join(''); // 將陣列用空字串區隔

        // 印出畫面
        suggestions.innerHTML = html;
      }

      let searchInput = document.querySelector('.search');
      let suggestions = document.querySelector('.suggestions');

      // 鍵盤按下觸發
      searchInput.addEventListener('keyup', displayMatches);
      // 改變後觸發
      searchInput.addEventListener('change', displayMatches);
    </script>
  </body>
</html>
